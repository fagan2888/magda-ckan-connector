<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="/v0/test-harness.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <title>Test Harness Example</title>
  </head>
  <body>
    <div id="root"></div>
    <script>
        var aspectBuilders = [
            {
                "aspectDefinition": {
                "id": "ckan-dataset",
                "name": "CKAN Dataset",
                "jsonSchema": {
                    "$schema": "http://json-schema.org/schema#",
                    "title": "Aspect capturing a complete representation of a dataset according to CKAN",
                    "type": "object"
                }
                },
                "builderFunctionString": "const copy = Object.assign({}, dataset);\r\ndelete copy.resources;\r\nreturn copy;"
            },
            {
                "aspectDefinition": {
                "id": "dcat-dataset-strings",
                "name": "DCAT Dataset properties as strings",
                "jsonSchema": {
                    "$schema": "http://json-schema.org/schema#",
                    "title": "DCAT Dataset properties as strings",
                    "description": "The [DCAT Dataset](https://www.w3.org/TR/vocab-dcat/#class-dataset) properties represented as strings.  This aspect is intended to be quite permissive of arbitrary property values, even those that may be difficult or impossible to interpret.",
                    "type": "object",
                    "properties": {
                    "title": {
                        "title": "A name given to the dataset.",
                        "type": "string"
                    },
                    "description": {
                        "title": "Free-text account of the dataset.",
                        "type": "string"
                    },
                    "issued": {
                        "title": "Date of formal issuance (e.g., publication) of the dataset.",
                        "type": "string",
                        "format": "date-time"
                    },
                    "modified": {
                        "title": "Most recent date on which the dataset was changed, updated or modified.",
                        "type": "string",
                        "format": "date-time"
                    },
                    "languages": {
                        "title": "The language(s) of this dataset.",
                        "type": "array",
                        "items": {
                        "type": "string"
                        }
                    },
                    "publisher": {
                        "title": "An entity responsible for making the dataset available.",
                        "type": "string"
                    },
                    "accrualPeriodicity": {
                        "title": "The frequency at which the dataset is published.",
                        "type": "string"
                    },
                    "spatial": {
                        "title": "Spatial coverage of the dataset.",
                        "type": "string"
                    },
                    "temporal": {
                        "title": "The temporal period that the dataset covers.",
                        "type": "object",
                        "properties": {
                        "start": {
                            "title": "The state date of the temporal period.",
                            "type": "string"
                        },
                        "end": {
                            "title": "The end date of the temporal period.",
                            "type": "string"
                        }
                        }
                    },
                    "themes": {
                        "title": "The main category of the dataset. A dataset can have multiple themes.",
                        "type": "array",
                        "items": {
                        "type": "string"
                        }
                    },
                    "keywords": {
                        "title": "Keywords or tag describing the dataset.",
                        "type": "string"
                    },
                    "contactPoint": {
                        "title": "Free-text account of who to contact about this dataset.",
                        "type": "string"
                    },
                    "landingPage": {
                        "title": "A Web page that can be navigated to in a Web browser to gain access to the dataset, its distributions and/or additional information. This should only be a MAGDA landing page if MAGDA is the official source of this dataset.",
                        "type": "string",
                        "format": "uri"
                    }
                    }
                }
                },
                "builderFunctionString": "var moment = libraries.moment;\r\n\r\nreturn {\r\n    title: dataset.title || dataset.name,\r\n    description: dataset.notes,\r\n    issued: dataset.metadata_created ? moment.utc(dataset.metadata_created).format() : undefined,\r\n    modified: dataset.metadata_modified ? moment.utc(dataset.metadata_modified).format() : undefined,\r\n    languages: dataset.language ? [dataset.language] : [],\r\n    publisher: (dataset.organization || {}).title,\r\n    accrualPeriodicity: dataset.update_freq,\r\n    spatial: dataset.spatial_coverage,\r\n    temporal: {\r\n        start: dataset.temporal_coverage_from,\r\n        end: dataset.temporal_coverage_to\r\n    },\r\n    themes: (dataset.groups || []).map(group => group.title),\r\n    keywords: (dataset.tags || []).map(tag => tag.name),\r\n    contactPoint: dataset.contact_point,\r\n    landingPage: source.getDatasetLandingPageUrl(dataset.id)\r\n};\r\n"
            },
            {
                "aspectDefinition": {
                "id": "source",
                "name": "Source",
                "jsonSchema": {
                    "$schema": "http://json-schema.org/schema#",
                    "title": "Aspect for capturing the source of a record",
                    "type": "object",
                    "properties": {
                    "type": {
                        "title": "The type of the source.",
                        "type": "string"
                    },
                    "url": {
                        "title": "The source URL.",
                        "type": "string"
                    },
                    "name": {
                        "title": "The human-friendly name of this source.",
                        "type": "string"
                    },
                    "problems": {
                        "title": "Problems encountered while creating this record from the source.",
                        "type": "array",
                        "items": {
                        "title": "A problem report.",
                        "type": "object",
                        "properties": {
                            "title": {
                            "title": "A short explanation of the problem.",
                            "type": "string"
                            },
                            "message": {
                            "title": "A message describing the problem.",
                            "type": "string"
                            },
                            "additionalInfo": {
                            "title": "Additional information about the problem."
                            }
                        }
                        }
                    }
                    }
                }
                },
                "builderFunctionString": "return {\r\n    type: 'ckan-dataset',\r\n    url: source.getPackageShowUrl(dataset.id),\r\n    name: source.name\r\n};\r\n"
            },
            {
                "aspectDefinition": {
                "id": "temporal-coverage",
                "name": "Temporal Coverage",
                "jsonSchema": {
                    "$schema": "http://json-schema.org/schema#",
                    "title": "The temporal period that the dataset covers",
                    "description": "Specifies the temporal period that the dataset covers as a list of time intervals.",
                    "type": "object",
                    "properties": {
                    "intervals": {
                        "title": "The intervals covered by this dataset.",
                        "type": "array",
                        "items": {
                        "title": "An interval covered by this dataset.",
                        "type": "object",
                        "properties": {
                            "start": {
                            "title": "The start date/time of the interval",
                            "type": "string",
                            "format": "date-time"
                            },
                            "startIndeterminate": {
                            "title": "An enumeration indicating the manner in which the start date is indeterminate.  If \"before\" or \"after\", the start date is not exactly known, but it is known to be before/after the date in the `start` property.  If \"now\", the start date is usually populated from the date when the dataset was last updated.  If \"unknown\", the start date is unknown and the `start` property is expected to be blank.",
                            "type": "string",
                            "enum": [
                                "unknown",
                                "now",
                                "before",
                                "after"
                            ]
                            },
                            "end": {
                            "title": "The end date/time of the interval",
                            "type": "string",
                            "format": "date-time"
                            },
                            "endIndeterminate": {
                            "title": "An enumeration indicating the manner in which the end date is indeterminate.  If \"before\" or \"after\", the end date is not exactly known, but it is known to be before/after the date in the `end` property.  If \"now\", the end date is usually populated from the date when the dataset was last updated.  If \"unknown\", the end date is unknown and the `end` property is expected to be undefined.",
                            "type": "string",
                            "enum": [
                                "unknown",
                                "now",
                                "before",
                                "after"
                            ]
                            }
                        }
                        }
                    }
                    }
                }
                },
                "setupFunctionString": "const moment = libraries.moment;\r\n\r\n// from moment.js, from-string.js\r\nvar tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\r\nvar isoTimes = [\r\n    ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\r\n    ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\r\n    ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\r\n    ['HH:mm', /\\d\\d:\\d\\d/],\r\n    ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\r\n    ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\r\n    ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\r\n    ['HHmm', /\\d\\d\\d\\d/],\r\n    ['HH', /\\d\\d/]\r\n];\r\n\r\nfor (var i = 0; i < isoTimes.length; ++i) {\r\n    // A time must follow whitespace or 'T' and occur at the end of the string.\r\n    isoTimes[i][1] = new RegExp('[\\\\sT]' + isoTimes[i][1].source + '(' + tzRegex.source + ')?$');\r\n}\r\n\r\nconst customDateFormats = [\r\n    'DD-MM-YYYY',\r\n    'DD-MMM-YYYY',\r\n    'DD-MMMM-YYYY',\r\n    'D-MMM-YYYY',\r\n    'D-MMMM-YYYY',\r\n    'MM-DD-YYYY',\r\n    'MMM-DD-YYYY',\r\n    'MMMM-DD-YYYY',\r\n    'MMM-DD-YY',\r\n    'MMMM-DD-YY',\r\n    'MMMM-YYYY',\r\n    'MMM-YYYY',\r\n    'MMMM-YY',\r\n    'MMM-YY',\r\n    'YYYY',\r\n    'YY',\r\n];\r\n\r\nconst customDateFormatRegexs = customDateFormats.map(format => {\r\n    return {\r\n        format: format,\r\n        regex: new RegExp('^' + format\r\n            .replace(/-/g, '[-\\\\/\\\\s]')\r\n            .replace(/M{4}/g, '[A-Za-z]+')\r\n            .replace(/M{3}/g, '[A-Za-z]{3}')\r\n            .replace(/[DMY]/g, '\\\\d'))\r\n    };\r\n});\r\n\r\nconst dateComponentSeparators = ['-', '/', ' '];\r\nconst dateTimeSeparators = ['T', ' '];\r\nconst formatScratch = [];\r\n\r\nfunction parseDateTimeString(s) {\r\n    if (!s) {\r\n        return moment.invalid();\r\n    }\r\n\r\n    // First try parsing this as an ISO8601 date/time\r\n    const iso = moment.utc(s, moment.ISO_8601, true);\r\n    if (iso.isValid()) {\r\n        return iso;\r\n    }\r\n\r\n    // Next try some custom date formats\r\n    const matchingDateFormats = customDateFormatRegexs.filter(format => format.regex.test(s));\r\n    const matchingTimeFormats = isoTimes.filter(format => format[1].test(s));\r\n    const includeTimeZone = tzRegex.test(s);\r\n\r\n    let formats = formatScratch;\r\n    formats.length = 0;\r\n\r\n    matchingDateFormats.forEach(dateFormat => {\r\n        dateComponentSeparators.forEach(dateComponentSeparator => {\r\n            const dateFormatWithSeparator = dateFormat.format.replace(/-/g, dateComponentSeparator);\r\n            formats.push(dateFormatWithSeparator);\r\n\r\n            dateTimeSeparators.forEach(dateTimeSeparator => {\r\n                matchingTimeFormats.forEach(timeFormat => {\r\n                    formats.push(dateFormatWithSeparator + dateTimeSeparator + timeFormat[0]);\r\n\r\n                    if (includeTimeZone) {\r\n                        formats.push(dateFormatWithSeparator + dateTimeSeparator + timeFormat[0] + 'Z');\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    });\r\n\r\n    return moment.utc(s, formats, true);\r\n}\r\n\r\nconst oneMillisecond = moment.duration(1);\r\n\r\nfunction getPrecisionFromMoment(m) {\r\n    const format = m.creationData().format;\r\n\r\n    // The most precise token in the format indicates the precision\r\n    if (/S/.test(format)) {\r\n        return oneMillisecond;\r\n    } else if (/s/.test(format)) {\r\n        return moment.duration(1, 'seconds');\r\n    } else if (/m/.test(format)) {\r\n        return moment.duration(1, 'minutes');\r\n    } else if (/[hH]/.test(format)) {\r\n        return moment.duration(1, 'hours');\r\n    } else if (/[DdE]/.test(format)) {\r\n        return moment.duration(1, 'days');\r\n    } else if (/[WwG]/.test(format)) {\r\n        return moment.duration(1, 'weeks');\r\n    } else if (/M/.test(format)) {\r\n        return moment.duration(1, 'months');\r\n    } else if (/Q/.test(format)) {\r\n        return moment.duration(1, 'quarters');\r\n    } else if (/[YgG]/.test(format)) {\r\n        return moment.duration(1, 'years');\r\n    } else {\r\n        return moment.duration(0);\r\n    }\r\n}\r\n\r\nfunction roundUp(date) {\r\n    const precision = getPrecisionFromMoment(date);\r\n    return moment.utc(date).add(precision).subtract(oneMillisecond);\r\n}\r\n\r\nconst nowRegExp = /^(Current|Now|Ongoing)$/i;\r\n\r\nfunction parseTemporalCoverageField(raw, now, shouldRoundUp) {\r\n    if (nowRegExp.test(raw)) {\r\n        return now;\r\n    } else {\r\n        const parsed = parseDateTimeString(raw);\r\n        if (parsed.isValid()) {\r\n            if (shouldRoundUp) {\r\n                roundUp(parsed);\r\n            }\r\n            return parsed;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n\r\nfunction parse(start, end, modified) {\r\n    const startDate = parseTemporalCoverageField(start, modified, false);\r\n    const endDate = parseTemporalCoverageField(end, modified, true);\r\n\r\n    let result = startDate && endDate ? {\r\n        start: startDate,\r\n        end: endDate\r\n    } : undefined;\r\n\r\n    if (start && end && !startDate && !endDate) {\r\n        // Unparsable text in both start and end - this might mean that there's split values in both (e.g. start=1999-2000, end=2010-2011).\r\n        // In this case we split each and take the earlier value for start and later value for end.\r\n        const startSplit = trySplit(start, modified);\r\n        const endSplit = trySplit(end, modified);\r\n\r\n        if (startSplit && endSplit) {\r\n            result = {\r\n                start: moment.min(startSplit.start, endSplit.start),\r\n                end: moment.max(startSplit.end, endSplit.end)\r\n            };\r\n        }\r\n    } else if (start && !end) {\r\n        result = trySplit(start, modified) || result;\r\n    } else if (!start && end) {\r\n        result = trySplit(end, modified) || result;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction trySplit(raw, modified) {\r\n    const parts = raw.split(/\\s*(?:to|-)\\s*/i);\r\n    if (parts.length !== 2) {\r\n        return undefined;\r\n    }\r\n\r\n    const first = parseTemporalCoverageField(parts[0], modified, false);\r\n    const second = parseTemporalCoverageField(parts[1], modified, false);\r\n\r\n    if (!first || !second) {\r\n        return undefined;\r\n    }\r\n\r\n    return {\r\n        start: moment.min(first, second),\r\n        end: roundUp(moment.max(first, second))\r\n    };\r\n}\r\n\r\nreturn {\r\n    parse\r\n};\r\n",
                "builderFunctionString": "const moment = libraries.moment;\r\n\r\nif (!dataset.temporal_coverage_from && !dataset.temporal_coverage_to) {\r\n    return undefined;\r\n}\r\n\r\nconst interval = setup.parse(dataset.temporal_coverage_from, dataset.temporal_coverage_to, moment.utc(dataset.metadata_modified));\r\nif (interval) {\r\n    return {\r\n        intervals: [interval]\r\n    };\r\n} else {\r\n    if (dataset.temporal_coverage_from || dataset.temporal_coverage_to) {\r\n        reportProblem('Unable to interpret temporal_coverage_from/to', 'Could not parse temporal coverage:\\n  from: ' + dataset.temporal_coverage_from + '\\n  to: ' + dataset.temporal_coverage_to);\r\n    }\r\n    return undefined;\r\n}\r\n"
            }
        ];

        $.ajax({
            url: '/v0/dataset?id=106f4e62-3c8e-4037-8e7d-6983e897342c',
            success: function(result) {
                var record = ckanConnector.createDatasetRecord(aspectBuilders, result);
                console.log(record);
            }
        });
    </script>
  </body>
</html>
